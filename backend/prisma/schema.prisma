generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String               @id @default(uuid())
  email              String               @unique
  username           String
  passwordHash       String
  displayName        String?
  bio                String?
  avatar             String?
  avatarUrl          String?
  handle             String?
  profileImage       String?
  twitter            String?
  discord            String?
  telegram           String?
  website            String?
  virtualSolBalance  Decimal              @default(100)
  isProfilePublic    Boolean              @default(true)
  solanaWallet       String?
  userTier           UserTier             @default(EMAIL_USER)
  walletAddress      String?              @unique
  walletNonce        String?
  walletVerified     Boolean              @default(false)
  simTokenBalance    Decimal?
  simBalanceUpdated  DateTime?
  monthlyConversions Decimal              @default(0)
  conversionResetAt  DateTime?
  premiumFeatures    String?              @default("[]")
  rewardPoints       Decimal              @default(0)
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  conversions        ConversionHistory[]
  copyTrades         CopyTrade[]
  holdings           Holding[]
  positions          Position[]
  realizedPnls       RealizedPnL[]
  rewardClaims       RewardClaim[]
  trades             Trade[]
  transactions       TransactionHistory[]
  trackedWallets     WalletTrack[]
}

model Trade {
  id             String               @id @default(uuid())
  userId         String
  tokenAddress   String
  mint           String
  tokenSymbol    String?
  tokenName      String?
  action         String
  side           String
  quantity       Decimal
  price          Decimal
  totalCost      Decimal
  costUsd        Decimal?
  proceedsUsd    Decimal?             // SELL: netSOL * solUsdAtFill
  realizedPnL    Decimal?
  marketCapUsd   Decimal?
  // Enhanced fields for proper PnL tracking
  solUsdAtFill   Decimal?             // SOL→USD FX rate at fill time
  grossSol       Decimal?             // Gross SOL before fees
  feesSol        Decimal?             // Total fees (DEX + L1 + priority)
  netSol         Decimal?             // Net SOL after fees (gross + fees for buy, gross - fees for sell)
  route          String?              // Trading route (Raydium/Orca/Jupiter/Pumpfun)
  priceSOLPerToken Decimal?           // Token price in SOL terms
  timestamp      DateTime             @default(now())
  createdAt      DateTime             @default(now())
  user           User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions   TransactionHistory[]

  @@index([userId, timestamp(sort: Desc)], map: "user_trades_recent")
  @@index([userId, createdAt(sort: Desc)], map: "user_trades_created")
  @@index([tokenAddress, timestamp(sort: Desc)], map: "token_trades_recent")
  @@index([mint, createdAt(sort: Desc)], map: "mint_trades_recent")
  @@index([userId, tokenAddress, timestamp(sort: Desc)], map: "user_token_history")
  @@index([userId, action, timestamp(sort: Desc)], map: "user_trade_type")
  @@index([timestamp(sort: Desc)], map: "trades_chronological")
}

model Holding {
  id              String   @id @default(uuid())
  userId          String
  tokenAddress    String
  tokenSymbol     String?
  tokenName       String?
  tokenImageUrl   String?
  entryPrice      Decimal
  quantity        Decimal  @default(0)
  avgBuyMarketCap Decimal?
  updatedAt       DateTime @updatedAt
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, tokenAddress], name: "user_token_position")
  @@index([userId, quantity(sort: Desc)], map: "user_holdings_by_size")
  @@index([tokenAddress, quantity(sort: Desc)], map: "token_holders_by_size")
  @@index([userId, updatedAt(sort: Desc)], map: "user_recent_holdings")
}

model TransactionHistory {
  id                String   @id @default(uuid())
  userId            String
  tokenAddress      String
  tokenSymbol       String?
  tokenName         String?
  action            String
  quantity          Decimal
  pricePerTokenSol  Decimal
  totalCostSol      Decimal
  feesSol           Decimal  @default(0)
  remainingQuantity Decimal
  costBasisSol      Decimal
  realizedPnLSol    Decimal?
  tradeId           String?
  executedAt        DateTime @default(now())
  createdAt         DateTime @default(now())
  trade             Trade?   @relation(fields: [tradeId], references: [id])
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, tokenAddress, executedAt], map: "user_token_fifo")
  @@index([userId, executedAt(sort: Desc)], map: "user_transactions_recent")
  @@index([tokenAddress, executedAt(sort: Desc)], map: "token_transactions")
  @@index([action, executedAt(sort: Desc)], map: "transaction_type")
  @@index([remainingQuantity], map: "available_lots")
}

model Token {
  address        String    @id
  symbol         String?
  name           String?
  imageUrl       String?
  logoURI        String?
  lastPrice      Decimal?
  lastTs         DateTime?
  volume5m       Decimal?  @default(0)
  volume1h       Decimal?  @default(0)
  volume24h      Decimal?  @default(0)
  priceChange5m  Decimal?  @default(0)
  priceChange1h  Decimal?  @default(0)
  priceChange24h Decimal?  @default(0)
  liquidityUsd   Decimal?  @default(0)
  marketCapUsd   Decimal?  @default(0)
  holderCount    BigInt?   @default(0)
  isNew          Boolean   @default(false)
  isTrending     Boolean   @default(false)
  momentumScore  Decimal?  @default(0)
  websites       String?   @default("[]")
  website        String?
  twitter        String?
  telegram       String?
  socials        String?   @default("[]")
  firstSeenAt    DateTime? @default(now())
  lastUpdatedAt  DateTime? @default(now())
  lastUpdated    DateTime?

  @@index([lastTs])
  @@index([isTrending, momentumScore])
  @@index([symbol])
  @@index([isNew])
}

model ConversionHistory {
  id                String   @id @default(uuid())
  userId            String
  virtualSolAmount  Decimal
  simTokensReceived Decimal
  conversionRate    Decimal
  transactionHash   String?
  status            String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)], map: "user_conversions_recent")
  @@index([status, createdAt(sort: Desc)], map: "conversions_by_status")
}

model RewardSnapshot {
  id          String   @id @default(cuid())
  epoch       Int      @unique
  totalPoints Decimal  @db.Decimal(38, 18)
  poolAmount  Decimal  @db.Decimal(38, 18)
  createdAt   DateTime @default(now())

  @@index([epoch])
}

model RewardClaim {
  id        String    @id @default(cuid())
  userId    String
  epoch     Int
  wallet    String
  amount    Decimal   @db.Decimal(38, 18)
  status    String    @default("PENDING")
  claimedAt DateTime?
  txSig     String?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, epoch], name: "userId_epoch")
  @@index([userId, epoch])
  @@index([epoch, claimedAt])
  @@index([status])
}

model Position {
  id        String        @id @default(uuid())
  userId    String
  mint      String
  qty       Decimal       @default(0)
  costBasis Decimal       @default(0)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  lots      PositionLot[]

  @@unique([userId, mint])
  @@index([userId, mint])
}

model PositionLot {
  id           String   @id @default(uuid())
  positionId   String
  userId       String
  mint         String
  qtyRemaining Decimal
  unitCostUsd  Decimal
  unitCostSol  Decimal? // Cost per token in SOL
  solUsdAtBuy  Decimal? // Freeze SOL→USD FX at buy time
  createdAt    DateTime @default(now())
  position     Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

  @@index([positionId, createdAt])
  @@index([userId, mint, createdAt])
}

model RealizedPnL {
  id        String   @id @default(uuid())
  userId    String
  mint      String
  pnl       Decimal  // Legacy: USD PnL
  pnlUsd    Decimal? // Explicit USD PnL (frozen at sell time)
  pnlSol    Decimal? // SOL PnL (frozen at sell time)
  tradeId   String?  // Reference to the sell trade
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([mint])
  @@index([tradeId])
}

model LotClosure {
  id               String   @id @default(uuid())
  lotId            String
  sellTradeId      String
  userId           String
  mint             String
  qtyClosedUnits   Decimal  // Token quantity closed (in base units or decimal)
  costSOL          Decimal  // SOL cost of this piece
  costUSD          Decimal  // USD cost of this piece (frozen at buy)
  proceedsSOL      Decimal  // SOL proceeds from this piece
  proceedsUSD      Decimal  // USD proceeds (frozen at sell)
  realizedPnlSOL   Decimal  // Realized PnL in SOL
  realizedPnlUSD   Decimal  // Realized PnL in USD
  createdAt        DateTime @default(now())

  @@index([lotId])
  @@index([sellTradeId])
  @@index([userId, mint, createdAt])
}

model PriceTick {
  id        String   @id @default(uuid())
  mint      String
  priceUsd  Decimal
  volume    Decimal  @default(0)
  timestamp DateTime @default(now())

  @@index([mint, timestamp])
}

model WalletTrack {
  id        String   @id @default(uuid())
  userId    String
  address   String
  alias     String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, address])
  @@index([userId])
  @@index([address])
}

model CopyTrade {
  id            String    @id @default(uuid())
  userId        String
  walletAddress String
  mint          String
  side          String
  qty           Decimal
  priceUsd      Decimal
  status        String    @default("PENDING")
  createdAt     DateTime  @default(now())
  executedAt    DateTime?
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([walletAddress, createdAt])
  @@index([status])
}

model WalletActivity {
  id                String    @id @default(uuid())
  walletAddress     String
  signature         String    @unique
  type              String    // SWAP, BUY, SELL, TRANSFER
  tokenInMint       String?   // Token being sold/sent
  tokenInSymbol     String?
  tokenInAmount     Decimal?
  tokenOutMint      String?   // Token being bought/received
  tokenOutSymbol    String?
  tokenOutAmount    Decimal?
  priceUsd          Decimal?  // USD value of the trade
  solAmount         Decimal?  // SOL involved in the trade
  program           String?   // DEX program (Raydium, Pump.fun, etc)
  fee               Decimal?  // Transaction fee in SOL
  profitLoss        Decimal?  // P&L if this is a sell
  marketCap         Decimal?  // Market cap at time of trade
  volume24h         Decimal?  // 24h volume at time of trade
  priceChange24h    Decimal?  // 24h price change percentage
  timestamp         DateTime
  blockTime         BigInt?
  createdAt         DateTime  @default(now())

  @@index([walletAddress, timestamp(sort: Desc)])
  @@index([signature])
  @@index([tokenInMint, timestamp(sort: Desc)])
  @@index([tokenOutMint, timestamp(sort: Desc)])
  @@index([type, timestamp(sort: Desc)])
  @@index([timestamp(sort: Desc)])
}

enum UserTier {
  EMAIL_USER
  WALLET_USER
  SIM_HOLDER
  ADMINISTRATOR
}
