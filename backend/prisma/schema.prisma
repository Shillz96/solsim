datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum UserTier {
  EMAIL_USER      // 10 SOL, limited features
  WALLET_USER     // Same as email if no $SIM tokens
  SIM_HOLDER      // 100 SOL, premium features
  ADMINISTRATOR   // Platform management access
}

model User {
  id                 String   @id @default(uuid())
  email              String   @unique
  username           String
  passwordHash       String
  
  // Profile information
  displayName        String?
  bio                String?
  avatar             String?
  avatarUrl          String?  // For uploaded avatars
  handle             String?  // Public display handle
  profileImage       String?  // Profile image URL
  
  // Social media links
  twitter            String?
  discord            String?
  telegram           String?
  website            String?
  
  // Trading preferences
  virtualSolBalance  Decimal  @default("100")  // Virtual SOL balance (in SOL units, not USD)
  isProfilePublic    Boolean  @default(true)
  
  // Creator rewards
  solanaWallet       String?  // Solana wallet for creator rewards (backend only)
  
  // Tier system and wallet verification
  userTier           UserTier @default(EMAIL_USER)
  walletAddress      String?  @unique // Connected Solana wallet address
  walletNonce        String?  // Nonce for wallet signature verification
  walletVerified     Boolean  @default(false)
  simTokenBalance    Decimal? // Cached $SIM token balance
  simBalanceUpdated  DateTime? // Last token balance check
  monthlyConversions Decimal  @default("0") // SOL converted this month
  conversionResetAt  DateTime? // Monthly limit reset date
  premiumFeatures    String?  @default("[]") // JSON array of enabled features
  
  // Reward system
  rewardPoints       Decimal  @default("0") // Accumulated points for rewards
  
  // Timestamps
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  
  // Relations
  trades             Trade[]
  holdings           Holding[]
  transactions       TransactionHistory[]
  conversions        ConversionHistory[]
  rewardClaims       RewardClaim[]
  positions          Position[]
  realizedPnls       RealizedPnL[]
  trackedWallets     WalletTrack[]
  copyTrades         CopyTrade[]
}

model Trade {
  id            String   @id @default(uuid())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String
  tokenAddress  String
  mint          String   // Token mint address (alias for tokenAddress)
  tokenSymbol   String?
  tokenName     String?
  action        String   // 'buy' or 'sell'
  side          String   // 'BUY' or 'SELL'
  quantity      Decimal  // Number of tokens traded
  price         Decimal  // Price per token in USD (from DexScreener/external API)
  totalCost     Decimal  // Total cost in SOL (amount of SOL spent/received)
  costUsd       Decimal? // Total cost in USD
  realizedPnL   Decimal? // Realized profit/loss in SOL (for sell trades only)
  marketCapUsd  Decimal? // Market cap in USD at time of trade (for market cap analysis)
  timestamp     DateTime @default(now())
  createdAt     DateTime @default(now())
  
  // Relations
  transactions  TransactionHistory[]
  
  // Optimized indexes for common query patterns
  @@index([userId, timestamp(sort: Desc)], name: "user_trades_recent")
  @@index([userId, createdAt(sort: Desc)], name: "user_trades_created")
  @@index([tokenAddress, timestamp(sort: Desc)], name: "token_trades_recent")
  @@index([mint, createdAt(sort: Desc)], name: "mint_trades_recent")
  @@index([userId, tokenAddress, timestamp(sort: Desc)], name: "user_token_history")
  @@index([userId, action, timestamp(sort: Desc)], name: "user_trade_type")
  @@index([timestamp(sort: Desc)], name: "trades_chronological")
}

model Holding {
  id              String  @id @default(uuid())
  user            User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  tokenAddress    String
  tokenSymbol     String?
  tokenName       String?
  tokenImageUrl   String?
  entryPrice      Decimal  // Entry price in USD per token (legacy format - calculated from USD price at purchase)
  quantity        Decimal  @default("0") // Number of tokens held
  avgBuyMarketCap Decimal? // Weighted average market cap at which user bought tokens (in USD)
  updatedAt       DateTime @updatedAt
  
  // Optimized indexes for common query patterns
  @@unique([userId, tokenAddress], name: "user_token_position")
  @@index([userId, quantity(sort: Desc)], name: "user_holdings_by_size")
  @@index([tokenAddress, quantity(sort: Desc)], name: "token_holders_by_size")
  @@index([userId, updatedAt(sort: Desc)], name: "user_recent_holdings")
}

// Transaction History for FIFO cost basis tracking
model TransactionHistory {
  id                String   @id @default(uuid())
  userId            String
  tokenAddress      String
  tokenSymbol       String?
  tokenName         String?
  
  // Transaction details
  action            String   // 'BUY', 'SELL', 'MIGRATED' (for initial holdings)
  quantity          Decimal  // Number of tokens in this transaction
  pricePerTokenSol  Decimal  // Price per token in SOL (not USD)
  totalCostSol      Decimal  // Total cost in SOL
  feesSol           Decimal  @default("0") // Transaction fees in SOL
  
  // FIFO tracking
  remainingQuantity Decimal  // For BUY transactions: amount not yet sold (for FIFO)
  costBasisSol      Decimal  // For BUY: total SOL invested; For SELL: SOL received
  realizedPnLSol    Decimal? // For SELL: realized profit/loss in SOL
  
  // Reference to original trade (if applicable)
  tradeId           String?
  trade             Trade?   @relation(fields: [tradeId], references: [id], onDelete: SetNull)
  
  // Timestamps
  executedAt        DateTime @default(now())
  createdAt         DateTime @default(now())
  
  // User relation
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Indexes for efficient FIFO queries
  @@index([userId, tokenAddress, executedAt], name: "user_token_fifo")
  @@index([userId, executedAt(sort: Desc)], name: "user_transactions_recent")
  @@index([tokenAddress, executedAt(sort: Desc)], name: "token_transactions")
  @@index([action, executedAt(sort: Desc)], name: "transaction_type")
  @@index([remainingQuantity], name: "available_lots")
}

model Token {
  address         String    @id // Primary key - token address
  symbol          String?
  name            String?
  imageUrl        String?
  logoURI         String?   // Logo URI for token  
  lastPrice       Decimal?  // Last known price in USD per token
  lastTs          DateTime?
  
  // Short-term metrics for DexScreener-style trending (all in USD)
  volume5m        Decimal?  @default("0")  // Trading volume in USD
  volume1h        Decimal?  @default("0")  // Trading volume in USD
  volume24h       Decimal?  @default("0")  // Trading volume in USD
  priceChange5m   Decimal?  @default("0")  // Price change percentage
  priceChange1h   Decimal?  @default("0")  // Price change percentage
  priceChange24h  Decimal?  @default("0")  // Price change percentage
  liquidityUsd    Decimal?  @default("0")  // Liquidity in USD
  marketCapUsd    Decimal?  @default("0")  // Market cap in USD
  holderCount     BigInt?   @default(0)    // Number of token holders
  
  // Discovery and trending flags
  isNew           Boolean   @default(false)
  isTrending      Boolean   @default(false)
  momentumScore   Decimal?  @default("0")
  
  // Social and metadata (JSON strings for SQLite compatibility)
  websites        String?   @default("[]")
  website         String?   // Single website URL
  twitter         String?   // Twitter handle
  telegram        String?   // Telegram link
  socials         String?   @default("[]")
  
  // Timestamps for tracking
  firstSeenAt     DateTime? @default(now())
  lastUpdatedAt   DateTime? @default(now())
  lastUpdated     DateTime? // Legacy field
  
  @@index([lastTs])
  @@index([isTrending, momentumScore])
  @@index([symbol])
  @@index([isNew])
}

// Conversion History for virtual SOL to $SIM token conversions
model ConversionHistory {
  id                String   @id @default(uuid())
  userId            String
  virtualSolAmount  Decimal  // Amount of virtual SOL converted
  simTokensReceived Decimal  // Amount of $SIM tokens received
  conversionRate    Decimal  // Rate at time of conversion
  transactionHash   String?  // Solana transaction hash (if applicable)
  status            String   // PENDING, COMPLETED, FAILED, ESCROWED
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // User relation
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, createdAt(sort: Desc)], name: "user_conversions_recent")
  @@index([status, createdAt(sort: Desc)], name: "conversions_by_status")
}

// Reward system models
model RewardSnapshot {
  id          String   @id @default(cuid())
  epoch       Int      @unique
  totalPoints Decimal  @db.Decimal(38,18)
  poolAmount  Decimal  @db.Decimal(38,18) // SIM tokens allocated
  createdAt   DateTime @default(now())
  
  @@index([epoch])
}

model RewardClaim {
  id         String   @id @default(cuid())
  userId     String
  epoch      Int
  wallet     String   // Wallet address for claiming
  amount     Decimal  @db.Decimal(38,18)
  status     String   @default("PENDING") // PENDING, COMPLETED, FAILED
  claimedAt  DateTime?
  txSig      String?
  createdAt  DateTime @default(now())
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, epoch], name: "userId_epoch")
  @@index([userId, epoch])
  @@index([epoch, claimedAt])
  @@index([status])
}

// Position tracking model for FIFO trading
model Position {
  id          String   @id @default(uuid())
  userId      String
  mint        String   // Token mint address
  qty         Decimal  @default("0")
  costBasis   Decimal  @default("0")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  lots        PositionLot[]
  
  @@unique([userId, mint])
  @@index([userId, mint])
}

// FIFO lot tracking for positions
model PositionLot {
  id             String   @id @default(uuid())
  positionId     String
  userId         String
  mint           String
  qtyRemaining   Decimal
  unitCostUsd    Decimal
  createdAt      DateTime @default(now())
  
  position       Position @relation(fields: [positionId], references: [id], onDelete: Cascade)
  
  @@index([positionId, createdAt])
  @@index([userId, mint, createdAt])
}

// Realized PnL tracking
model RealizedPnL {
  id        String   @id @default(uuid())
  userId    String
  mint      String
  pnl       Decimal
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, createdAt])
  @@index([mint])
}

// Price tick history for candles
model PriceTick {
  id        String   @id @default(uuid())
  mint      String
  priceUsd  Decimal
  volume    Decimal  @default("0")
  timestamp DateTime @default(now())
  
  @@index([mint, timestamp])
}

// Wallet tracking for copy trading
model WalletTrack {
  id        String   @id @default(uuid())
  userId    String
  address   String   // Wallet address being tracked
  alias     String?  // User-defined name for wallet
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, address])
  @@index([userId])
  @@index([address])
}

// Copy trade records
model CopyTrade {
  id           String   @id @default(uuid())
  userId       String
  walletAddress String  // Source wallet being copied
  mint         String
  side         String   // BUY or SELL
  qty          Decimal
  priceUsd     Decimal
  status       String   @default("PENDING") // PENDING, EXECUTED, FAILED
  createdAt    DateTime @default(now())
  executedAt   DateTime?
  
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, createdAt])
  @@index([walletAddress, createdAt])
  @@index([status])
}