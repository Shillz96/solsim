generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                      String                 @id @default(dbgenerated("gen_random_uuid()::text"))
  email                   String                 @unique
  handle                  String                 // Consolidated from username/handle - now required
  passwordHash            String
  displayName             String?
  bio                     String?
  avatarUrl               String?                // Consolidated from avatar/avatarUrl/profileImage
  twitter                 String?
  discord                 String?
  telegram                String?
  website                 String?
  virtualSolBalance       Decimal                @default(100)
  realSolBalance          Decimal                @default(0) // Real SOL deposited for mainnet trading
  tradingMode             TradeMode              @default(PAPER) // Current trading mode preference
  realSolDepositAddress   String?                // User-specific deposit address (if using deposited balance)
  isProfilePublic         Boolean                @default(true)
  solanaWallet            String?
  userTier                UserTier               @default(EMAIL_USER)
  walletAddress           String?                @unique
  walletNonce             String?
  walletVerified          Boolean                @default(false)
  vsolTokenBalance        Decimal?
  vsolBalanceUpdated      DateTime?
  monthlyConversions      Decimal                @default(0)
  conversionResetAt       DateTime?
  premiumFeatures         String?                @default("[]")
  rewardPoints            Decimal                @default(0)
  rewardWalletAddress     String?                // Solana wallet address for receiving hourly rewards
  emailVerified           Boolean                @default(false)
  emailVerificationToken  String?                @unique
  emailVerificationExpiry DateTime?
  passwordResetToken      String?                @unique
  passwordResetExpiry     DateTime?
  lastClaimTime           DateTime?
  createdAt               DateTime               @default(now())
  updatedAt               DateTime               @updatedAt
  conversions             ConversionHistory[]
  copyTrades              CopyTrade[]
  positions               Position[]
  realizedPnls            RealizedPnL[]
  rewardClaims            RewardClaim[]
  trades                  Trade[]
  transactions            TransactionHistory[]
  trackedWallets          WalletTrack[]
  walletTrackerSettings   WalletTrackerSettings?
  solPurchases            SolPurchase[]
  perpPositions           PerpPosition[]
  perpTrades              PerpTrade[]
  liquidations            Liquidation[]
  tokenWatches            TokenWatch[]
  deposits                Deposit[]
  withdrawals             Withdrawal[]
  wallets                 UserWallet[]
  // Chat relations
  chatMessages            ChatMessage[]
  moderationActions       ChatModerationAction[]
  // Badge system relations
  userBadges              UserBadge[]
  userModerationStatus    UserModerationStatus?
  // Chat moderation fields
  chatStrikes             Int                    @default(0)
  chatMutedUntil          DateTime?
  bannedFromChat          Boolean                @default(false)
}

model Trade {
  id               String               @id @default(uuid())
  userId           String
  tokenAddress     String
  mint             String
  tokenSymbol      String?
  tokenName        String?
  action           String
  side             String
  quantity         Decimal
  price            Decimal
  totalCost        Decimal
  costUsd          Decimal?
  proceedsUsd      Decimal? // SELL: netSOL * solUsdAtFill
  realizedPnL      Decimal?
  marketCapUsd     Decimal?
  // Enhanced fields for proper PnL tracking
  solUsdAtFill     Decimal? // SOLâ†’USD FX rate at fill time
  grossSol         Decimal? // Gross SOL before fees
  feesSol          Decimal? // Total fees (DEX + L1 + priority)
  netSol           Decimal? // Net SOL after fees (gross + fees for buy, gross - fees for sell)
  route            String? // Trading route (Raydium/Orca/Jupiter/Pumpfun)
  priceSOLPerToken Decimal? // Token price in SOL terms
  // Real trading fields
  tradeMode        TradeMode            @default(PAPER) // Paper or Real trading
  realTxSignature  String?              // Solana transaction signature for real trades
  realTxStatus     TransactionStatus?   // Status of real transaction
  fundingSource    FundingSource?       // How real trade was funded (deposited or wallet)
  pumpPortalFee    Decimal?             // PumpPortal API fee (0.5% or 1%)
  timestamp        DateTime             @default(now())
  createdAt        DateTime             @default(now())
  user             User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions     TransactionHistory[]

  @@index([userId, timestamp(sort: Desc)], map: "user_trades_recent")
  @@index([userId, createdAt(sort: Desc)], map: "user_trades_created")
  @@index([tokenAddress, timestamp(sort: Desc)], map: "token_trades_recent")
  @@index([mint, createdAt(sort: Desc)], map: "mint_trades_recent")
  @@index([userId, tokenAddress, timestamp(sort: Desc)], map: "user_token_history")
  @@index([userId, action, timestamp(sort: Desc)], map: "user_trade_type")
  @@index([timestamp(sort: Desc)], map: "trades_chronological")
  @@index([userId, side, createdAt(sort: Desc)], map: "user_trade_side") // PERFORMANCE: For buy/sell history queries
  @@index([userId, tradeMode, timestamp(sort: Desc)], map: "user_trade_mode") // PERFORMANCE: Filter by trading mode
  @@index([realTxSignature], map: "real_tx_signature") // PERFORMANCE: Lookup by transaction signature
}

// REMOVED: Holding model (deprecated - use Position model instead)

model TransactionHistory {
  id                String   @id @default(uuid())
  userId            String
  tokenAddress      String
  tokenSymbol       String?
  tokenName         String?
  action            String
  quantity          Decimal
  pricePerTokenSol  Decimal
  totalCostSol      Decimal
  feesSol           Decimal  @default(0)
  remainingQuantity Decimal
  costBasisSol      Decimal
  realizedPnLSol    Decimal?
  tradeId           String?
  executedAt        DateTime @default(now())
  createdAt         DateTime @default(now())
  trade             Trade?   @relation(fields: [tradeId], references: [id])
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, tokenAddress, executedAt], map: "user_token_fifo")
  @@index([userId, executedAt(sort: Desc)], map: "user_transactions_recent")
  @@index([tokenAddress, executedAt(sort: Desc)], map: "token_transactions")
  @@index([action, executedAt(sort: Desc)], map: "transaction_type")
  @@index([remainingQuantity], map: "available_lots")
}

model Token {
  address        String    @id
  symbol         String?
  name           String?
  imageUrl       String?
  logoURI        String?
  lastPrice      Decimal?
  lastTs         DateTime?
  volume5m       Decimal?  @default(0)
  volume1h       Decimal?  @default(0)
  volume24h      Decimal?  @default(0)
  priceChange5m  Decimal?  @default(0)
  priceChange1h  Decimal?  @default(0)
  priceChange24h Decimal?  @default(0)
  liquidityUsd   Decimal?  @default(0)
  marketCapUsd   Decimal?  @default(0)
  holderCount    BigInt?   @default(0)
  isNew          Boolean   @default(false)
  isTrending     Boolean   @default(false)
  momentumScore  Decimal?  @default(0)
  websites       String?   @default("[]")
  website        String?
  twitter        String?
  telegram       String?
  socials        String?   @default("[]")
  firstSeenAt    DateTime? @default(now())
  lastUpdatedAt  DateTime? @default(now())
  lastUpdated    DateTime?

  @@index([lastTs])
  @@index([isTrending, momentumScore])
  @@index([symbol])
  @@index([isNew])
}

model ConversionHistory {
  id                 String   @id @default(uuid())
  userId             String
  virtualSolAmount   Decimal
  vsolTokensReceived Decimal
  conversionRate     Decimal
  transactionHash    String?
  status             String
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)], map: "user_conversions_recent")
  @@index([status, createdAt(sort: Desc)], map: "conversions_by_status")
}

model RewardSnapshot {
  id          String   @id @default(cuid())
  epoch       Int      @unique
  totalPoints Decimal  @db.Decimal(38, 18)
  poolAmount  Decimal  @db.Decimal(38, 18)
  createdAt   DateTime @default(now())

  @@index([epoch])
}

model RewardClaim {
  id        String    @id @default(cuid())
  userId    String
  epoch     Int
  wallet    String
  amount    Decimal   @db.Decimal(38, 18)
  status    String    @default("PENDING")
  claimedAt DateTime?
  txSig     String?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, epoch], name: "userId_epoch")
  @@index([epoch, claimedAt])
  @@index([status])
}

model Position {
  id        String        @id @default(uuid())
  userId    String
  mint      String
  qty       Decimal       @default(0)
  costBasis Decimal       @default(0)
  tradeMode TradeMode     @default(PAPER) // Separate positions for paper and real trading
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  lots      PositionLot[]

  @@unique([userId, mint, tradeMode]) // Unique per user, token, and trading mode
  @@index([userId, qty(sort: Desc)], map: "user_positions_by_qty") // PERFORMANCE: For portfolio queries filtering by qty > 0
  @@index([userId, tradeMode, qty(sort: Desc)], map: "user_positions_by_mode") // PERFORMANCE: Filter by trading mode
}

model PositionLot {
  id           String    @id @default(uuid())
  positionId   String
  userId       String
  mint         String
  qtyRemaining Decimal
  unitCostUsd  Decimal
  unitCostSol  Decimal?  // Cost per token in SOL
  solUsdAtBuy  Decimal?  // Freeze SOLâ†’USD FX at buy time
  tradeMode    TradeMode @default(PAPER) // Match parent position's trade mode
  createdAt    DateTime  @default(now())
  position     Position  @relation(fields: [positionId], references: [id], onDelete: Cascade)

  @@index([positionId, createdAt])
  @@index([userId, mint, createdAt])
  @@index([userId, mint, tradeMode, createdAt]) // PERFORMANCE: FIFO queries by trade mode
}

model RealizedPnL {
  id        String    @id @default(uuid())
  userId    String
  mint      String
  pnl       Decimal   // Legacy: USD PnL
  pnlUsd    Decimal?  // Explicit USD PnL (frozen at sell time)
  pnlSol    Decimal?  // SOL PnL (frozen at sell time)
  tradeMode TradeMode @default(PAPER) // Trading mode for this PnL
  tradeId   String?   // Reference to the sell trade
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([mint, createdAt(sort: Desc)], map: "mint_pnl_chronological") // PERFORMANCE: For mint-specific PnL queries
  @@index([tradeId])
  @@index([userId, tradeMode, createdAt]) // PERFORMANCE: Filter PnL by trading mode
}

model LotClosure {
  id             String   @id @default(uuid())
  lotId          String
  sellTradeId    String
  userId         String
  mint           String
  qtyClosedUnits Decimal // Token quantity closed (in base units or decimal)
  costSOL        Decimal // SOL cost of this piece
  costUSD        Decimal // USD cost of this piece (frozen at buy)
  proceedsSOL    Decimal // SOL proceeds from this piece
  proceedsUSD    Decimal // USD proceeds (frozen at sell)
  realizedPnlSOL Decimal // Realized PnL in SOL
  realizedPnlUSD Decimal // Realized PnL in USD
  createdAt      DateTime @default(now())

  @@index([lotId])
  @@index([sellTradeId])
  @@index([userId, mint, createdAt])
}

model PriceTick {
  id        String   @id @default(uuid())
  mint      String
  priceUsd  Decimal
  volume    Decimal  @default(0)
  timestamp DateTime @default(now())

  @@index([mint, timestamp])
}

model WalletTrack {
  id        String   @id @default(uuid())
  userId    String
  address   String
  alias     String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, address])
  @@index([userId])
  @@index([address])
}

model WalletTrackerSettings {
  id     String @id @default(uuid())
  userId String @unique

  // Transaction Type Filters
  showBuys         Boolean @default(true)
  showSells        Boolean @default(true)
  showFirstBuyOnly Boolean @default(false)

  // Market Cap Filters (USD)
  minMarketCap Decimal? // Null = no minimum
  maxMarketCap Decimal? // Null = no maximum

  // Transaction Amount Filters (USD)
  minTransactionUsd Decimal? // Null = no minimum
  maxTransactionUsd Decimal? // Null = no maximum

  // Image Filter
  requireImages Boolean @default(false) // If true, only show trades with token images

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model CopyTrade {
  id            String    @id @default(uuid())
  userId        String
  walletAddress String
  mint          String
  side          String
  qty           Decimal
  priceUsd      Decimal
  status        String    @default("PENDING")
  createdAt     DateTime  @default(now())
  executedAt    DateTime?
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([walletAddress, createdAt])
  @@index([status])
}

model WalletActivity {
  id              String   @id @default(uuid())
  walletAddress   String
  signature       String   @unique
  type            String // SWAP, BUY, SELL, TRANSFER
  tokenInMint     String? // Token being sold/sent
  tokenInSymbol   String?
  tokenInAmount   Decimal?
  tokenInLogoURI  String? // Token logo image URL
  tokenOutMint    String? // Token being bought/received
  tokenOutSymbol  String?
  tokenOutAmount  Decimal?
  tokenOutLogoURI String? // Token logo image URL
  priceUsd        Decimal? // USD value of the trade
  solAmount       Decimal? // SOL involved in the trade
  program         String? // DEX program (Raydium, Pump.fun, etc)
  fee             Decimal? // Transaction fee in SOL
  profitLoss      Decimal? // P&L if this is a sell
  marketCap       Decimal? // Market cap at time of trade
  volume24h       Decimal? // 24h volume at time of trade
  priceChange24h  Decimal? // 24h price change percentage
  timestamp       DateTime
  blockTime       BigInt?
  createdAt       DateTime @default(now())

  @@index([walletAddress, timestamp(sort: Desc)])
  @@index([signature])
  @@index([tokenInMint, timestamp(sort: Desc)])
  @@index([tokenOutMint, timestamp(sort: Desc)])
  @@index([type, timestamp(sort: Desc)])
  @@index([timestamp(sort: Desc)])
}

model SolPurchase {
  id                   String    @id @default(uuid())
  userId               String
  realSolAmount        Decimal // Amount of real SOL spent
  simulatedSolAmount   Decimal // Amount of simulated SOL received
  transactionSignature String    @unique // Solana transaction signature
  walletAddress        String // User's wallet address that made the payment
  status               String    @default("PENDING") // PENDING, COMPLETED, FAILED
  tierLabel            String? // e.g., "Tier 1", "Tier 3 - Popular"
  createdAt            DateTime  @default(now())
  completedAt          DateTime?
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([status, createdAt(sort: Desc)])
  @@index([transactionSignature])
}

model Notification {
  id        String               @id @default(uuid())
  userId    String
  type      NotificationType
  category  NotificationCategory @default(GENERAL)
  title     String
  message   String
  read      Boolean              @default(false)
  metadata  String?              @default("{}") // JSON string for additional data
  actionUrl String? // Optional URL to navigate to
  createdAt DateTime             @default(now())

  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, read, createdAt(sort: Desc)])
  @@index([type, createdAt(sort: Desc)])
}

enum UserTier {
  EMAIL_USER
  WALLET_USER
  VSOL_HOLDER
  MODERATOR
  ADMINISTRATOR
}

enum NotificationType {
  TRADE_EXECUTED // Trade completed
  TRADE_MILESTONE // 10th, 50th, 100th trade
  POSITION_GAIN // Position up 10%, 25%, 50%, 100%
  POSITION_MOON // 2x, 5x, 10x gains
  POSITION_LOSS // Position down significantly
  DAILY_PNL // Daily profit milestone
  PORTFOLIO_ATH // Portfolio all-time high
  PORTFOLIO_RECOVERY // Recovered from loss
  LEADERBOARD_RANK // Entered top 100, top 10
  LEADERBOARD_MOVE // Moved up ranks
  REWARD_AVAILABLE // Rewards to claim
  REWARD_CLAIMED // Reward claimed
  WALLET_TRACKER_TRADE // KOL made a trade
  WALLET_TRACKER_GAIN // KOL position mooning
  ACHIEVEMENT // Fun achievements
  PRICE_ALERT // Price target hit
  TRENDING_TOKEN // Token you hold is trending
  SYSTEM // System announcements
  WELCOME // Welcome message
}

enum NotificationCategory {
  TRADE
  PORTFOLIO
  LEADERBOARD
  REWARDS
  WALLET_TRACKER
  ACHIEVEMENT
  SYSTEM
  GENERAL
}

enum TradeMode {
  PAPER // Virtual/simulated trading
  REAL  // Real mainnet trading
}

enum FundingSource {
  DEPOSITED // Trading from platform-held balance (Lightning API)
  WALLET    // Trading from connected user wallet (Local Transaction API)
}

enum TransactionStatus {
  PENDING   // Transaction submitted but not confirmed
  CONFIRMED // Transaction confirmed on-chain
  FAILED    // Transaction failed
}

// Perpetual Trading Models
model PerpPosition {
  id               String      @id @default(uuid())
  userId           String
  mint             String
  side             String // 'LONG' or 'SHORT'
  leverage         Decimal
  entryPrice       Decimal
  currentPrice     Decimal
  positionSize     Decimal // Token quantity
  marginAmount     Decimal // Collateral in SOL
  unrealizedPnL    Decimal     @default(0)
  marginRatio      Decimal     @default(0) // Current margin / maintenance margin
  liquidationPrice Decimal
  status           String      @default("OPEN") // 'OPEN', 'CLOSED', 'LIQUIDATED'
  openedAt         DateTime    @default(now())
  closedAt         DateTime?
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
  user             User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  perpTrades       PerpTrade[]

  @@index([userId])
  @@index([status])
  @@index([status, marginRatio])
  @@index([userId, mint, status])
}

model PerpTrade {
  id         String        @id @default(uuid())
  userId     String
  positionId String?
  mint       String
  side       String // 'LONG' or 'SHORT'
  action     String // 'OPEN', 'CLOSE', 'LIQUIDATE', 'INCREASE', 'DECREASE'
  leverage   Decimal
  quantity   Decimal // Position size change
  entryPrice Decimal
  exitPrice  Decimal?
  marginUsed Decimal
  pnl        Decimal?
  fees       Decimal       @default(0)
  timestamp  DateTime      @default(now())
  createdAt  DateTime      @default(now())
  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  position   PerpPosition? @relation(fields: [positionId], references: [id])

  @@index([userId, timestamp(sort: Desc)])
  @@index([mint, timestamp(sort: Desc)])
  @@index([positionId])
}

model Liquidation {
  id               String   @id @default(uuid())
  userId           String
  positionId       String
  mint             String
  side             String
  liquidationPrice Decimal
  positionSize     Decimal
  marginLost       Decimal
  timestamp        DateTime @default(now())
  createdAt        DateTime @default(now())
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, timestamp(sort: Desc)])
  @@index([positionId])
}

// Warp Pipes Hub - Token Discovery & Tracking
model TokenDiscovery {
  id               String    @id @default(cuid())
  mint             String    @unique
  symbol           String?
  name             String?
  logoURI          String?   // IPFS metadata URI or direct image URL
  description      String?   // Token description from metadata
  imageUrl         String?   // Parsed image URL from metadata

  // Social links (from metadata)
  twitter          String?
  telegram         String?
  website          String?

  // State tracking (bonded, graduating, new)
  state            String    // 'bonded' | 'graduating' | 'new'
  previousState    String?   // Track state transitions

  // Bonding curve data (for bonded/graduating tokens)
  bondingCurveProgress  Decimal? // 0-100% progress toward migration
  bondingCurveKey       String?  // Bonding curve account address

  // Pool data (for new tokens)
  poolAddress      String?
  poolType         String?   // 'pumpswap' | 'raydium' | 'meteora'
  poolCreatedAt    DateTime?
  liquidityUsd     Decimal?

  // Market data
  marketCapUsd     Decimal?  // Market cap in USD
  volume24h        Decimal?  // 24h trading volume
  volumeChange24h  Decimal?  // 24h volume change percentage
  priceUsd         Decimal?  // Current price in USD
  priceChange24h   Decimal?  // 24h price change percentage
  txCount24h       Int?      // 24h transaction count
  holderCount      Int?      // Number of token holders

  // Enhanced trading metrics
  lastTradeTs      DateTime? // Timestamp of last trade (for liveness detection)
  volume24hSol     Decimal?  @default(0) // 24h volume in SOL terms
  buys24h          Int?      @default(0) // Number of buy transactions in 24h
  sells24h         Int?      @default(0) // Number of sell transactions in 24h
  uniqueTraders24h Int?      @default(0) // Unique traders in 24h
  ath              Decimal?  // All-time high price

  // Bonding curve specifics
  solRaised        Decimal?  @default(0) // Total SOL raised in bonding curve
  solToGraduate    Decimal?  @default(0) // SOL needed to reach graduation

  // Creator data
  creatorWallet    String?   // Token creator wallet address

  // Health capsule data
  freezeRevoked    Boolean   @default(false)
  mintRenounced    Boolean   @default(false)
  priceImpact1Pct  Decimal?  // Price impact for 1% swap
  creatorVerified  Boolean   @default(false)

  // Holder concentration & safety
  top1HolderPct    Decimal?  // Top holder concentration percentage
  top5HolderPct    Decimal?  // Top 5 holders concentration percentage
  mintAuthorityRevoked Boolean @default(false) // Whether mint authority is revoked
  sellable         Boolean   @default(true)    // Whether token is sellable (no honeypot)
  tradeFailRate    Decimal?  @default(0)       // Percentage of failed trades

  // Trending metrics
  hotScore         Decimal   @default(0)
  watcherCount     Int       @default(0)

  // Status classification (lifecycle state)
  status           String    @default("LAUNCHING") // LAUNCHING | ACTIVE | ABOUT_TO_BOND | BONDED | DEAD

  // Timestamps
  firstSeenAt      DateTime  @default(now())
  lastUpdatedAt    DateTime  @updatedAt
  stateChangedAt   DateTime  @default(now())

  @@index([state, hotScore(sort: Desc)], map: "token_discovery_state_hot")
  @@index([mint], map: "token_discovery_mint")
  @@index([state, lastUpdatedAt(sort: Desc)], map: "token_discovery_state_updated")
  @@index([volume24h(sort: Desc)], map: "token_discovery_volume")
  @@index([marketCapUsd(sort: Desc)], map: "token_discovery_market_cap")
  @@index([holderCount(sort: Desc)], map: "token_discovery_holder_count")
  @@index([status, lastUpdatedAt(sort: Desc)], map: "token_discovery_status_updated")
  @@index([lastTradeTs(sort: Desc)], map: "token_discovery_last_trade")
}

model TokenWatch {
  id                  String   @id @default(cuid())
  userId              String
  mint                String

  // Watch preferences
  notifyOnGraduation  Boolean  @default(true)
  notifyOnMigration   Boolean  @default(true)
  notifyOnPriceChange Boolean  @default(false)

  // Tracking
  currentState        String   // State when watch was added
  createdAt           DateTime @default(now())

  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, mint], name: "userId_mint")
  @@index([userId], map: "token_watch_user")
  @@index([mint], map: "token_watch_mint")
  @@index([userId, createdAt(sort: Desc)], map: "token_watch_user_recent")
}

// Deposit tracking for real SOL deposits
model Deposit {
  id                String    @id @default(uuid())
  userId            String
  amount            Decimal
  txSignature       String    @unique
  status            String    @default("PENDING") // PENDING, CONFIRMED, FAILED
  depositAddress    String
  fromAddress       String?
  confirmedAt       DateTime?
  createdAt         DateTime  @default(now())
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, createdAt(sort: Desc)])
  @@index([status, createdAt(sort: Desc)])
  @@index([txSignature])
}

// Withdrawal tracking for real SOL withdrawals
model Withdrawal {
  id                String    @id @default(uuid())
  userId            String
  amount            Decimal
  fee               Decimal   @default(0)
  netAmount         Decimal
  toAddress         String
  txSignature       String?   @unique
  status            String    @default("PENDING") // PENDING, PROCESSING, CONFIRMED, FAILED
  errorMessage      String?
  requestedAt       DateTime  @default(now())
  processedAt       DateTime?
  confirmedAt       DateTime?
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, requestedAt(sort: Desc)])
  @@index([status, requestedAt(sort: Desc)])
  @@index([txSignature])
}

// Multi-wallet system for managing multiple wallets per user
enum WalletType {
  PLATFORM_GENERATED // Original deposit wallets we create
  IMPORTED // User imported their own wallet
}

model UserWallet {
  id           String     @id @default(uuid())
  userId       String
  name         String // User-friendly name ("Main Wallet", "Trading Wallet")
  walletType   WalletType // PLATFORM_GENERATED, IMPORTED
  address      String     @unique
  encryptedKey String? // Encrypted private key (only for imported wallets)
  balance      Decimal    @default(0)
  isActive     Boolean    @default(false) // Currently selected for trading
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isActive])
  @@index([userId, walletType])
}

// ============================================================
// Chat System Models
// ============================================================

// Chat messages - per-token room messages
model ChatMessage {
  id        String   @id @default(uuid())
  roomId    String   // Token mint address (or 'lobby' for global chat)
  userId    String
  content   String   @db.VarChar(280) // Max 280 characters (Twitter-style)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([roomId, createdAt(sort: Desc)], map: "chat_room_recent") // Fetch recent messages
  @@index([userId, createdAt(sort: Desc)], map: "chat_user_recent") // User's chat history
  @@index([roomId, userId, createdAt(sort: Desc)], map: "chat_room_user") // Per-user per-room messages
}

// Moderation actions - track mutes, bans, strikes
model ChatModerationAction {
  id           String    @id @default(uuid())
  userId       String    // User being moderated
  moderatorId  String?   // Admin who took action (null for automated)
  action       String    // 'MUTE', 'BAN', 'STRIKE', 'UNMUTE', 'UNBAN', 'CLEAR_STRIKES'
  reason       String?   // Optional reason
  duration     Int?      // Duration in minutes (for mutes)
  expiresAt    DateTime? // When mute expires (null for bans)
  createdAt    DateTime  @default(now())
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)], map: "moderation_user_recent") // User's moderation history
  @@index([action, createdAt(sort: Desc)], map: "moderation_action_type") // Filter by action type
  @@index([expiresAt], map: "moderation_expiry") // Find expired mutes
}

// ============================================================
// Badge System Models
// ============================================================

// Badge Rarity Enum
enum BadgeRarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
  MYTHIC
}

// Badge Category Enum
enum BadgeCategory {
  FOUNDER
  TRADING
  COMMUNITY
  SPECIAL
  MODERATION
}

// Badge Definitions
model Badge {
  id          String      @id @default(uuid())
  name        String      @unique
  description String
  icon        String
  color       String
  rarity      BadgeRarity @default(COMMON)
  category    BadgeCategory
  isVisible   Boolean     @default(true)
  requirements Json?
  createdAt   DateTime    @default(now())
  
  userBadges  UserBadge[]
  
  @@index([category, rarity], map: "badge_category_rarity")
}

// User Badges - Track earned badges
model UserBadge {
  id        String   @id @default(uuid())
  userId    String
  badgeId   String
  earnedAt  DateTime @default(now())
  isActive  Boolean  @default(true)
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge     Badge    @relation(fields: [badgeId], references: [id])
  
  @@unique([userId, badgeId], map: "user_badge_unique")
  @@index([userId, isActive], map: "user_active_badges")
  @@index([earnedAt(sort: Desc)], map: "badge_earned_at")
}

// User Moderation Status - Track trust scores and moderation state
model UserModerationStatus {
  id              String    @id @default(uuid())
  userId          String    @unique
  trustScore      Int       @default(100)
  strikes         Int       @default(0)
  isMuted         Boolean   @default(false)
  mutedUntil      DateTime?
  isBanned        Boolean   @default(false)
  bannedUntil     DateTime?
  lastViolation   DateTime?
  violationCount  Int       @default(0)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([trustScore], map: "user_trust_score")
  @@index([isMuted, mutedUntil], map: "user_mute_status")
  @@index([isBanned, bannedUntil], map: "user_ban_status")
}
